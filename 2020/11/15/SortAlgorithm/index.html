<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Lingfeng Zhu">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Lingfeng Zhu">
    
    <meta name="keywords" content="machine learning,deep learning,recommender system">
    
    <meta name="description" content="">
    <meta name="description" content="排序算法在很多领域得到相当重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。此文整理了一些基本的排序算法以及相关拓展。">
<meta property="og:type" content="article">
<meta property="og:title" content="Sort Algorithm">
<meta property="og:url" content="https://lingfengzhu.github.io/2020/11/15/SortAlgorithm/index.html">
<meta property="og:site_name" content="Vinn&#39;s Studio">
<meta property="og:description" content="排序算法在很多领域得到相当重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。此文整理了一些基本的排序算法以及相关拓展。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-15T00:35:38.000Z">
<meta property="article:modified_time" content="2021-09-08T10:35:10.541Z">
<meta property="article:author" content="Lingfeng Zhu">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>Sort Algorithm · Vinn&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Vinn&#39;s Studio</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Sort Algorithm</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Vinn's Studio</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(https://source.unsplash.com/random)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Sort Algorithm
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">15.1k</span>Reading time: <span class="post-count reading-time">62 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/11/15</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <script type="text/javascript"
  src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>排序算法在很多领域得到相当重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。此文整理了一些基本的排序算法以及相关拓展。</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">最差时间复杂度</th>
<th style="text-align:center">最优时间复杂度</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">类别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">内部比较排序</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">内部比较排序</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">内部比较排序</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^S)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^S)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">内部比较排序</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n \log n)$</td>
<td style="text-align:center">$O(n \log n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">内部比较排序</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n \log n)$</td>
<td style="text-align:center">$O(n \log n)$</td>
<td style="text-align:center">$O(\log n)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">内部比较排序</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n \log n)$</td>
<td style="text-align:center">$O(n \log n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">内部比较排序</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n + n \log n - n \log m)$</td>
<td style="text-align:center">$O(m + n)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">非比较排序</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">$O(k)$</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">非比较排序</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(m(n + B))$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(m(n + B))$</td>
<td style="text-align:center">$O(n + B)$</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">非比较排序</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Basic-Definitions"><a href="#Basic-Definitions" class="headerlink" title="Basic Definitions"></a>Basic Definitions</h2><ul>
<li><p><strong>排序算法稳定性</strong> (Sorting Algorithm Stability): 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变（即在原序列中，<code>r[i]==r[j]</code> 且 <code>r[i]</code> 在 <code>r[j]</code> 之前，而在排序后的序列中，<code>r[i]</code> 仍在 <code>r[j]</code> 之前），则称这种排序算法是稳定的；否则称为不稳定的。</p>
</li>
<li><p><strong>基于比较的排序算法</strong>: 若一个排序算法是基于内部比较的，则一般情况下，他的平均时间复杂度不可能优于 $O(n\log n)$​。这就是基于内部比较的排序算法的时间复杂度下限。</p>
<blockquote>
<p> <strong>Proof</strong>: </p>
<ol>
<li><p>对于 n 个未知的待排序元素，可能的排序结果共有 $A_n^n = n!$ 种；</p>
</li>
<li><p>在经过一次比较后，有两个元素之间的前后顺序被确定，在这个情况下，可能的排序结果剩下 $\frac{n!}{2}$​​ 种：</p>
<p>假设比较了序列中的 A 和 B 这两个元素：A 与 B 在序列中的地位是平等的，在 $n!$ 种可能的排序结果中，A 排在 B 前面的结果数与 A 排在 B 后面的结果数相等，均为 $\frac{n!}{2}$（注意到当 $n &gt; 1$ 时，$n!$ 的因子中包含 2，因此 $n!$ 必为偶数），经过比较后，A 与 B 之间的前后顺序确定，不妨假设 A 大于 B，则排序结果中，A 排在 B 前面的那 $\frac{n!}{2}$ 种结果不再成立，剩下 A 排在 B 后面的那 $\frac{n!}{2}$​ 种结果；</p>
</li>
<li><p>依此类推，每经过一次比较，可能的排序结果数都会减半，直到经过 m 次比较，剩余 $\frac{n!}{2^m}$​​​ 种可能的排序结果；</p>
</li>
<li><p>当 $\frac{n!}{2^m} \leq 1$​​ 时，可能的排序结果只剩一种，此时排序结束，计算此时的比较次数 m:</p>
<script type="math/tex; mode=display">
\frac{n!}{2^m} \leq 1 \\
2^m \geq n! \\
m \geq \log{n!}</script><p>（还可以这样考虑：n 个数有 $n!$​ 个可能的排列情况，也就是说基于比较的排序算法的判定树有 $n!$​ 个叶子结点；排序需要的最少比较次数可以近似地看做这棵树的深度 $\log{n!}$）</p>
<p>利用斯特林公式（Stirling’s approximation）$n ! \approx \sqrt{2 \pi n}\left(\frac{n}{e}\right)^{n}$​，有：</p>
<script type="math/tex; mode=display">
m \geq \log{n!} \approx log(\sqrt{2 \pi n}\left(\frac{n}{e}\right)^{n})=\log{\sqrt{2 \pi }} + \frac{1}{2}\log{n} + n\log{\frac{n}{e}}</script><p>即，最少的比较次数为：</p>
<script type="math/tex; mode=display">
O(m) = O\left(n\log{n}-n\log{e} + \frac{1}{2}\log{n} + \log{\sqrt{2 \pi }}\right)=O(n\log{n})</script></li>
</ol>
</blockquote>
</li>
<li><p><strong>最优时间复杂度</strong> (Best Case Time Complexity): 最好情况下（一般为给定数组已经排序完成；最好情况视具体排序算法而定），该排序算法的时间复杂度。</p>
</li>
<li><p><strong>最差时间复杂度</strong> (Worst Case Time Complexity): 最坏情况下（如：给定数组的排列完全随机或给定数组已经反向排序等；最差情况视具体排序算法而定），该排序算法的时间复杂度。</p>
</li>
<li><p><strong>平均时间复杂度</strong> (Average Case Time Complexity): 所有可能情况下 该排序算法的时间复杂度的平均值。</p>
</li>
<li><p><strong>注意</strong>：本文中的 $\log n$ 默认底数为 $2$。</p>
</li>
</ul>
<p>关于时间复杂度的更多信息参见：<a href="https://lingfengzhu.xyz/2020/11/16/Time-Complexity/" target="_blank" rel="noopener">时间复杂度</a></p>
<h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><p><strong>冒泡排序</strong><br>重复地访问过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>冒泡排序算法的运作如下（以从小到大排序为例）：</p>
<ol>
<li>正向遍历，对于每一对相邻元素，比较这两个元素的大小，如果前一个比后一个大，就把它们两个调换位置。完成一次遍历后，数组的最后一个元素就是最大元素；</li>
<li>排除最后一个元素，针对剩余数组重复上述步骤；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)，参见短冒泡排序 (short bubble sort)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(1)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<p>冒泡排序代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> passnum <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>): <span class="comment"># passnum 表示每次遍历的终点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(passnum):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                temp = alist[i]</span><br><span class="line">                alist[i] = alist[i+<span class="number">1</span>]</span><br><span class="line">                alist[i+<span class="number">1</span>] = temp</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>] </span><br><span class="line">bubbleSort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><h3 id="Short-Bubble-Sort"><a href="#Short-Bubble-Sort" class="headerlink" title="Short Bubble Sort"></a>Short Bubble Sort</h3><p><strong>短冒泡排序</strong> 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到 $O(n)$。这种算法就是短冒泡排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># short bubble sort: 若第一次遍历时没有进行交换，则直接停止</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortBubbleSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    flag = <span class="literal">True</span> <span class="comment"># 用于标记是否需要交换：flag == True 表示需要交换；flag == False 表示已经不需要交换</span></span><br><span class="line">    passnum = len(alist) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> passnum &gt; <span class="number">0</span> <span class="keyword">and</span> flag:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(passnum):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                temp = alist[i]</span><br><span class="line">                alist[i] = alist[i+<span class="number">1</span>]</span><br><span class="line">                alist[i+<span class="number">1</span>] = temp</span><br><span class="line">        passnum = passnum - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist=[<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]  </span><br><span class="line">shortBubbleSort(alist)  </span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[20, 30, 40, 50, 60, 70, 80, 90, 100, 110]
</code></pre><h3 id="Cocktail-Sort"><a href="#Cocktail-Sort" class="headerlink" title="Cocktail Sort"></a>Cocktail Sort</h3><p><strong>鸡尾酒排序</strong> 又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p>
<p>以从小到大排序为例：</p>
<ol>
<li>正向遍历：对于每一对相邻元素，比较这两个元素的大小，如果前一个比后一个大，就把它们两个调换位置。完成一次遍历后，数组的最后一个元素就是最大元素；</li>
<li>反向遍历：排除最后一个元素，针对剩余数组，从后往前遍历，对于每一对相邻元素，比较这两个元素的大小，如果前一个比后一个大，就把它们两个调换位置。完成一次反向遍历后，数组的第一个元素就是最小元素；</li>
<li>排除第一个和最后一个元素，针对剩余数组重复上述步骤 1 和 2；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(1)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<p>鸡尾酒排序代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cocktailSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    size = len(alist)</span><br><span class="line">    sign = <span class="number">1</span> <span class="comment"># 标记：sign == 1 表示需要继续排序; sign == 0 表示已经完成排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(size / <span class="number">2</span>)): <span class="comment"># i 的作用类似 passnum，用于标记已经排序完成的部分</span></span><br><span class="line">        <span class="keyword">if</span> sign:</span><br><span class="line">            sign = <span class="number">0</span> <span class="comment"># 先将 sign 设置为 0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, size - <span class="number">1</span> - i):</span><br><span class="line">                <span class="keyword">if</span> alist[j] &gt; alist[j + <span class="number">1</span>]:</span><br><span class="line">                    alist[j], alist[j + <span class="number">1</span>] = alist[j + <span class="number">1</span>], alist[j]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(size - <span class="number">2</span> - i, i, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> alist[k] &lt; alist[k - <span class="number">1</span>]:</span><br><span class="line">                    sign = <span class="number">1</span> <span class="comment"># 反向排序时还存在需要交换的相邻元素（表明整个排序过程还未完成），故重新将 sign 设置为 1</span></span><br><span class="line">                    alist[k], alist[k - <span class="number">1</span>] = alist[k - <span class="number">1</span>], alist[k]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 排序已完成</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist=[<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]  </span><br><span class="line">cocktailSort(alist)  </span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[20, 30, 40, 50, 60, 70, 80, 90, 100, 110]
</code></pre><h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p><strong>选择排序</strong> 多次遍历数组，每次都遍历选出最大/最小元素，放到数组最后/最前的位置，直到排序完成。</p>
<p>选择排序算法的运作如下（以从小到大排序为例）：</p>
<ol>
<li>遍历数组，找到最大元素（通过维护一个“最大元素的位置”实现），将它放到数组最后一个位置（通过与数组最后一个元素交换位置实现）；</li>
<li>排除最后一个元素（即最大元素），针对剩下的数组重复上述步骤；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到完成排序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(1)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 不稳定（位于数组最后&#x2F;最前位置的元素可能会因为被当前找到的最大&#x2F;最小元素交换而失去稳定性：如[5,9,1,3,1] 中，选择排序会将最大值 9 与末尾的 1 交换，导致两个 1 的相对位置改变）</span><br></pre></td></tr></table></figure>
<p>选择排序代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> fillslot <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment"># fillshot 表示每次遍历的终点</span></span><br><span class="line">        positionOfMax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> location <span class="keyword">in</span> range(<span class="number">1</span>, fillslot + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> alist[location] &gt; alist[positionOfMax]:</span><br><span class="line">                positionOfMax = location</span><br><span class="line">                </span><br><span class="line">        temp = alist[fillslot]</span><br><span class="line">        alist[fillslot] = alist[positionOfMax]</span><br><span class="line">        alist[positionOfMax] = temp</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>] </span><br><span class="line">selectionSort(alist) </span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p><strong>插入排序</strong> 在数组中维护一个“已排序”的子序列，对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序算法的运作如下（以从小到大排序为例）：</p>
<ol>
<li>将数组的第一个元素初始化为已排序子序列；</li>
<li>取出下一个元素（已排序子序列的右边第一个元素）作为新元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果已排序子序列中的某元素大于新元素，则将该元素后移一个位置，空出一个空位；</li>
<li>重复步骤3（空位会不断左移），直到找到已排序的元素小于或者等于新元素；</li>
<li>将新元素插入到空位中；</li>
<li>重复步骤2 ~ 5，直到完成排序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 ------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(1)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, len(alist)):</span><br><span class="line">        currentvalue = alist[index] <span class="comment"># 当前要插入的元素</span></span><br><span class="line">        position = index <span class="comment"># 准备插入的位置</span></span><br><span class="line">        <span class="keyword">while</span> position &gt; <span class="number">0</span> <span class="keyword">and</span> alist[position - <span class="number">1</span>] &gt; currentvalue:</span><br><span class="line">            alist[position] = alist[position - <span class="number">1</span>] <span class="comment"># 元素向后移动</span></span><br><span class="line">            position = position - <span class="number">1</span> <span class="comment"># 准备插入的空位左移</span></span><br><span class="line">        alist[position] = currentvalue <span class="comment"># 插入</span></span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>] </span><br><span class="line">insertionSort(alist) </span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><h3 id="Binary-Insert-Sort"><a href="#Binary-Insert-Sort" class="headerlink" title="Binary Insert Sort"></a>Binary Insert Sort</h3><p><strong>二分插入排序</strong> 对于插入排序，如果比较操作的代价比交换操作大的话，在寻找元素插入的位置时可以采用 <em>二分查找法</em> 来减少插入过程中比较操作的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- O(nlogn)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n^2)</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(1)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<p>当 n 较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryInsertSort</span><span class="params">(alist)</span>:</span></span><br><span class="line"><span class="comment"># 二分插入排序: 小-&gt;大</span></span><br><span class="line"><span class="comment"># 在直接插入排序的基础上使用了折半/二分查找的方法 </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(alist)):</span><br><span class="line">        index = alist[i] <span class="comment"># 准备插入的元素</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        hight = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= hight:</span><br><span class="line">            mid = (low + hight) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> index &gt; alist[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hight = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 跳出while循环后 low == mid, hight = low - 1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, low, <span class="number">-1</span>):</span><br><span class="line">            alist[j] = alist[j - <span class="number">1</span>] <span class="comment"># 元素向后移动</span></span><br><span class="line">        alist[low] = index <span class="comment"># 插入</span></span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>] </span><br><span class="line">binaryInsertSort(alist) </span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h2><p><strong>希尔排序</strong> 即分组插入排序，也叫递减增量排序(Diminishing Increment Sort)，是插入排序的一种更高效的改进版本：</p>
<ol>
<li>将数组按照一定的<strong>步长/增量</strong>（步长为 <code>n</code> 表示：对于任意 <code>i</code>, 下标为 <code>i</code>, <code>i+n</code>, <code>i+2n</code>, <code>i+3n</code> … 的元素组成同一个子序列）拆分为若干个较小的子序列（事实上，若步长为 <code>n</code>， 则拆分为 <code>n</code> 个子序列），然后对每个子序列分别使用插入排序（<strong>这样可以让一个元素一次性地朝最终位置前进一大步</strong><code>--&gt;</code><strong>克服了插入排序的一个导致低效的缺点：每步排序中，除了这一步的新元素外，其他元素都只能移动最多一位</strong>）；</li>
<li>再取越来越小的步长进行分组插入排序；</li>
<li>算法的最后一步（此时步长为1）就是普通的插入排序，但是到了这步，数组已经几乎排列好了，因此这步的排序效率也比较高（<strong>利用了插入排序在对几乎已经排好序的数据操作时效率较高的优点</strong>）。</li>
</ol>
<p>注意：一般取 $\frac{n}{2}$ 作为第一个步长，此后依次用 $\frac{n}{4}$, $\frac{n}{8}$, … 直到最后一个步长为 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(n^S)，其中 1.3&lt;S&lt;&#x3D;2，根据步长序列的不同而不同。</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- O(n)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- 根据步长序列的不同而不同，可能是 O(nlogn) 或 O(n^S),其中 1.3&lt;S&lt;&#x3D;2</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(1)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 不稳定（虽然单独的插入排序是稳定的，但是相同元素在不同的子序列中分别进行插入排序时相对位置可能会被打乱：例如，假设算法进行到步长为 2 的那一步时，数列为 [3,20,5,10,8,8]，此时按照步长将其分为两个子序列 [3,5,8] 和 [20,10,8]，子序列分别插入排序后结果为 [3,5,8] 和 [8, 10, 20]，此时数列变为 [3,8,5,10,8,20]，两个 8 的相对位置就改变了）</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    gap = len(alist) // <span class="number">2</span> <span class="comment"># 表示 步长 or 增量</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range(gap):</span><br><span class="line">            gapInsertionSort(alist, start, gap)</span><br><span class="line">        print(<span class="string">'After increments of size'</span>, gap, <span class="string">'The list is'</span>, alist)</span><br><span class="line">        gap = gap //<span class="number">2</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gapInsertionSort</span><span class="params">(alist, start, gap)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    对 alist 中的一个子序列（该子序列以 start 作为起点，步长为 gap）进行插入排序</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start+gap, len(alist), gap):</span><br><span class="line">        currentvalue = alist[i]</span><br><span class="line">        position = i</span><br><span class="line">        <span class="keyword">while</span> position &gt;= gap <span class="keyword">and</span> alist[position - gap] &gt; currentvalue:</span><br><span class="line">            alist[position] = alist[position - gap]</span><br><span class="line">            position = position - gap</span><br><span class="line">        alist[position] = currentvalue</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>] </span><br><span class="line">shellSort(alist) </span><br><span class="line">print(<span class="string">'Finally: '</span>, alist)</span><br></pre></td></tr></table></figure>
<pre><code>After increments of size 4 The list is [20, 26, 44, 17, 54, 31, 93, 55, 77]
After increments of size 2 The list is [20, 17, 44, 26, 54, 31, 77, 55, 93]
After increments of size 1 The list is [17, 20, 26, 31, 44, 54, 55, 77, 93]
Finally:  [17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><p><strong>归并排序</strong> 采用分治法（以从小到大排序为例）：</p>
<ul>
<li>分割：把当前序列平均分割成前后两个子序列，对每个子序列递归地执行该分割操作 <code>-&gt;</code> 最终得到许多长度为1的子序列；</li>
<li>集成/归并：对于两个子序列，将他们的所有元素按照大小顺序排列在一起，集成为一个排好序的序列 <code>-&gt;</code> 最终归并得到完整的排好序的序列。一个归并单元的步骤如下：<ol>
<li>申请空间，使其大小为两个已经排序的子序列之和，该空间用来存放合并后的序列，称为合并空间/临时数组；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间/临时数组，并将指向较小元素的指针移动到下一位置；</li>
<li>重复步骤3直到某一指针到达序列尾部；</li>
<li>将另一序列剩下的所有元素直接复制到合并空间/临时数组尾部；</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(nlogn) </span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- O(nlogn)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(nlogn) </span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(n)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<p><strong>关于时间复杂度</strong>：</p>
<ol>
<li>假设长度为 $n$ 的数组的归并排序整体的时间复杂度为 $T(n)$，其中包括递归步骤中 2 个长为 $n/2$ 的子序列的归并排序消耗的时间复杂度 $T(n/2)$，以及最后把这两个有序子序列合并成一个数组的时间复杂度 $O(n)$。因此有 $T(n) = 2\times T(n/2) + O(n)$；</li>
<li>类似的，如果考虑长度为 $n/2$ 的数组，我们有 $T(n/2) = 2 \times T(n/4) + O(n/2)$；</li>
<li>将 2 中的式子代入 1 中，可以得到：$T(n) = 2 \times 2 \times T(n/4) + 2 \times O(n)$；</li>
<li>考虑长度为 $n/4$ 的数组，再经过一次上述代入可以得到：$T(n) = 2^3 \times T(n/8) + 3 \times O(n)$；</li>
<li>可以得出结论，对于 $m = 1,2,3,…$，有递推式：$T(n) = 2^m \times T(\frac{n}{2^m}) + m \times O(n)$；</li>
<li>当 $m$ 取值达到 $logn$ 时，有 $\frac{n}{2^m}=1$，表示 $m$ 的取值已达上限，此时有：$T(n) = 2^{logn} \times T(1) + (logn) \times O(n) = n \times T(1) + O(nlogn)$；</li>
<li>由于 $T(1)$ 为常量，在计算时间复杂度时可忽略，且因此有：$T(n) = O(nlogn)$。</li>
</ol>
<p><strong>关于空间复杂度</strong>：额外需要的空间就是那个合并空间/临时数组占用的空间 $O(n)$ 和递归时（显然需要 $logn$ 次递归）压入栈的数据占用的空间 $O(logn)$，故整体的空间复杂度为 $O(n)$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    print(<span class="string">'Splitting '</span>, alist)</span><br><span class="line">    <span class="keyword">if</span> len(alist) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = len(alist) // <span class="number">2</span></span><br><span class="line">        lefthalf = alist[:mid]</span><br><span class="line">        righthalf = alist[mid:]</span><br><span class="line">        </span><br><span class="line">        mergeSort(lefthalf) <span class="comment"># 递归</span></span><br><span class="line">        mergeSort(righthalf) <span class="comment"># 递归</span></span><br><span class="line">        </span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> <span class="comment"># i 为第一个子序列上的指针， j 为第二个子序列上的指针，k 为合并序列上的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; len(lefthalf) <span class="keyword">and</span> j &lt; len(righthalf): <span class="comment"># 当两个序列的指针都没有达到尾部</span></span><br><span class="line">            <span class="keyword">if</span> lefthalf[i] &lt; righthalf[j]:</span><br><span class="line">                alist[k] = lefthalf[i]</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alist[k] = righthalf[j]</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> i &lt; len(lefthalf): <span class="comment"># 当其中一个序列的指针达到尾部</span></span><br><span class="line">            alist[k] = lefthalf[i]  </span><br><span class="line">            i = i + <span class="number">1</span> </span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> j &lt; len(righthalf): <span class="comment"># 当另一个序列的指针达到尾部</span></span><br><span class="line">            alist[k] = righthalf[j]  </span><br><span class="line">            j = j + <span class="number">1</span> </span><br><span class="line">            k = k + <span class="number">1</span> </span><br><span class="line">    print(<span class="string">"Merging "</span>,alist)</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]  </span><br><span class="line">mergeSort(alist)  </span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<pre><code>Splitting  [54, 26, 93, 17, 77, 31, 44, 55, 20]
Splitting  [54, 26, 93, 17]
Splitting  [54, 26]
Splitting  [54]
Merging  [54]
Splitting  [26]
Merging  [26]
Merging  [26, 54]
Splitting  [93, 17]
Splitting  [93]
Merging  [93]
Splitting  [17]
Merging  [17]
Merging  [17, 93]
Merging  [17, 26, 54, 93]
Splitting  [77, 31, 44, 55, 20]
Splitting  [77, 31]
Splitting  [77]
Merging  [77]
Splitting  [31]
Merging  [31]
Merging  [31, 77]
Splitting  [44, 55, 20]
Splitting  [44]
Merging  [44]
Splitting  [55, 20]
Splitting  [55]
Merging  [55]
Splitting  [20]
Merging  [20]
Merging  [20, 55]
Merging  [20, 44, 55]
Merging  [20, 31, 44, 55, 77]
Merging  [17, 20, 26, 31, 44, 54, 55, 77, 93]
[17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><p>另外一种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># another method</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(alist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    mid = len(alist) // <span class="number">2</span></span><br><span class="line">    left = mergeSort(alist[:mid])</span><br><span class="line">    right = mergeSort(alist[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    r, l = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l &lt; len(left) <span class="keyword">and</span> r &lt; len(right): <span class="comment"># 当两个序列的指针都没有达到尾部</span></span><br><span class="line">        <span class="keyword">if</span> left[l] &lt;= right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += list(left[l:]) <span class="comment"># 剩下的所有元素直接复制到合并序列尾部</span></span><br><span class="line">    result += list(right[r:]) <span class="comment"># 剩下的所有元素直接复制到合并序列尾部</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]  </span><br><span class="line">mergeSort(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><p><strong>快速排序</strong> 是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 $n$ 个元素要 $O(n\log{n})$ 次比较。在最坏状况下则需要 $O(n^2)$ 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 $O(n\log{n})$ 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序算法的运作如下（以从小到大排序为例）：</p>
<ol>
<li>从序列中挑出一个元素（通常选择<strong>第一个元素</strong>或者<strong>中间位置的元素</strong>），作为”基准” (pivot)；</li>
<li>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（与基准相同的数可以到任一边），这个过程称为分区 (partition) 操作；</li>
<li>对每个分区序列递归地进行步骤 1~2，递归的结束条件是分区序列的长度为 0 或 1，这时序列整体已经排序完成。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 ------------ 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 --------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- 每次选取的基准都恰好是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，每次递归步骤时间复杂度为 O(n)，因此整体的时间复杂度为 O(n^2)</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 每次选取的基准都恰好是中位数，这样每次都均匀的划分出两个分区，只需要 logn 次划分就能结束递归，每次递归步骤时间复杂度为 O(n)，因此整体的时间复杂度为 O(nlogn)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(nlogn)</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ 主要是递归造成的栈空间的使用（用来保存 left 和 right 等局部变量），取决于递归树的深度，一般为 O(logn)，最差情况下（每次选取的基准都恰好是最大&#x2F;最小的元素）为 O(n)       </span><br><span class="line">&#x2F;&#x2F; 稳定性 ---------- 不稳定，在进行元素交换时可能导致不稳定</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：若每次选取的基准都恰好是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行 $n-1$ 次划分才能结束递归，则快速排序算法就退化成了冒泡排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(alist, first, last)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    分区操作：</span></span><br><span class="line"><span class="string">    该写法使用两个指针 leftmark 和 rightmark 进行分区：</span></span><br><span class="line"><span class="string">        leftmark 从序列左边向右扫描，直到遇见大于 pivot 的元素时候停止；</span></span><br><span class="line"><span class="string">        rightmark 从序列右边向左扫描，直到遇见小于 pivot 的元素时候停止；</span></span><br><span class="line"><span class="string">        若两个个指针在遇见对方前停止了，则交换两个指针指向元素的位置；</span></span><br><span class="line"><span class="string">        最终当两个指针相遇时，就保证了相遇点左边的元素都小于 pivot，相遇点右边的元素都大于 pivot；</span></span><br><span class="line"><span class="string">        相遇点就是两个分区的分割点，将基准值放在这个位置，然后返回这个位置的下标。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pivotvalue = alist[first] <span class="comment"># 基准值选取了第一个元素</span></span><br><span class="line">    leftmark = first + <span class="number">1</span></span><br><span class="line">    rightmark = last</span><br><span class="line">    </span><br><span class="line">    done = <span class="literal">False</span> <span class="comment"># 用于标记是否已经完成分区</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        <span class="keyword">while</span> leftmark &lt;= rightmark <span class="keyword">and</span> \</span><br><span class="line">        alist[leftmark] &lt;= pivotvalue:</span><br><span class="line">            leftmark = leftmark + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> leftmark &lt;= rightmark <span class="keyword">and</span> \</span><br><span class="line">        alist[rightmark] &gt;= pivotvalue:</span><br><span class="line">            rightmark = rightmark - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftmark &gt; rightmark:</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = alist[leftmark]</span><br><span class="line">            alist[leftmark] = alist[rightmark]</span><br><span class="line">            alist[rightmark] = temp</span><br><span class="line">        </span><br><span class="line">    temp = alist[first]</span><br><span class="line">    alist[first] = alist[rightmark]</span><br><span class="line">    alist[rightmark] = temp</span><br><span class="line">    print(alist)</span><br><span class="line">    <span class="keyword">return</span> rightmark <span class="comment"># return the position  where the pivotvalue should be</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    quickSortHelper(alist, <span class="number">0</span>, len(alist) - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSortHelper</span><span class="params">(alist, first, last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        splitpoint = partition(alist, first, last)</span><br><span class="line">        quickSortHelper(alist, first, splitpoint - <span class="number">1</span>)</span><br><span class="line">        quickSortHelper(alist, splitpoint + <span class="number">1</span>, last)</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]  </span><br><span class="line">quickSort(alist)  </span><br><span class="line">print(<span class="string">"Finally"</span>, alist)</span><br></pre></td></tr></table></figure>
<pre><code>[31, 26, 20, 17, 44, 54, 77, 55, 93]
[17, 26, 20, 31, 44, 54, 77, 55, 93]
[17, 26, 20, 31, 44, 54, 77, 55, 93]
[17, 20, 26, 31, 44, 54, 77, 55, 93]
[17, 20, 26, 31, 44, 54, 55, 77, 93]
Finally [17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><p>另外一种写法，更简洁，但是使用了额外空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># another method: 更简洁，但是使用了额外空间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(alist)</span>:</span>    </span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string">    此写法的分区操作直接使用了额外空间，而不是利用指针在原序列上操作</span></span><br><span class="line"><span class="string">    """</span>    </span><br><span class="line">    <span class="keyword">if</span> len(alist) &gt;= <span class="number">2</span>:  <span class="comment"># 递归入口及出口        </span></span><br><span class="line">        mid = alist[len(alist)//<span class="number">2</span>]  <span class="comment"># 选取基准值，此处选择了序列中间的元素，也可以选取第一个或最后一个元素        </span></span><br><span class="line">        left, right = [], []  <span class="comment"># 定义基准值左右两侧的列表        </span></span><br><span class="line">        alist.remove(mid)  <span class="comment"># 从原始数组中移除基准值        </span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> alist:            </span><br><span class="line">            <span class="keyword">if</span> num &gt;= mid:                </span><br><span class="line">                right.append(num)            </span><br><span class="line">            <span class="keyword">else</span>:                </span><br><span class="line">                left.append(num)        </span><br><span class="line">        <span class="keyword">return</span> quickSort(left) + [mid] + quickSort(right)    </span><br><span class="line">    <span class="keyword">else</span>:        </span><br><span class="line">        <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]  </span><br><span class="line">quickSort(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[17, 20, 26, 31, 44, 54, 55, 77, 93]
</code></pre><p><strong>注意</strong>：Java 系统提供的 Arrays.sort 函数，对于基础类型，底层使用快速排序；对于非基础类型，底层使用归并排序。请问是为什么？</p>
<p><strong>答</strong>：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它并不稳定；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 </p>
<h3 id="Linked-List-Quick-Sort"><a href="#Linked-List-Quick-Sort" class="headerlink" title="Linked List Quick Sort"></a>Linked List Quick Sort</h3><p><strong>链表快速排序</strong> 使用快速排序对链表进行排序。此处使用两个指针进行分区操作：（该操作的核心为：确保 <code>i</code> 以及 <code>i</code> 之前的元素都小于基准数，<code>i</code> 之后的元素都大于基准数；<code>j</code> 用于遍历一次整个链表，指向当前处理的那个元素）</p>
<ul>
<li>step1: 初始化时，<code>i</code> 指向链表首元素；<code>j = i + 1</code>，指向链表第二个元素。基准数字为当前 <code>i</code> 指向的数字（即首元素）；  </li>
<li>step2: 若 <code>j</code> 指向的元素大于基准数：直接跳过，执行 <code>j++</code>；  </li>
<li>step3: 若 <code>j</code> 指向的元素小于基准数：首先 <code>i</code> 向后移动一位（<code>i++</code>），然后交换 <code>i</code> 和 <code>j</code> 所指向的元素（<code>swap(i,j)</code>），最后 <code>j</code> 向后移动一位（<code>j++</code>）；  </li>
<li>step4: 最后，当 <code>j</code> 已经超出索引，则一次循环结束，交换当前 <code>i</code> 指向的元素和基准数；  </li>
<li>step5: 以基准数当前所在的位置为界划分了左右两个子链表，递归地对这两个子链表进行上述快速排序的操作即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="comment"># 链表结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item=None)</span>:</span></span><br><span class="line">        self.item = item  <span class="comment"># 数据域</span></span><br><span class="line">        self.next = <span class="literal">None</span>  <span class="comment"># 指针域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表类，生成链表以及定义相关方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 生成链表，这里使用list来生成</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.head = Node(item[<span class="number">0</span>])</span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> item[<span class="number">1</span>:]:</span><br><span class="line">            p.next = Node(i)</span><br><span class="line">            p = p.next</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历显示</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            print(p.item, end=<span class="string">' '</span>)</span><br><span class="line">            p = p.next</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据索引取值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getItem</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count &lt; index:</span><br><span class="line">            p = p.next</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> p.item</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据索引设值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setItem</span><span class="params">(self, index, item)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count &lt; index:</span><br><span class="line">            p = p.next</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        p.item = item</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 互换</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapItem</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        t = self.getItem(j)</span><br><span class="line">        self.setItem(j, self.getItem(i))</span><br><span class="line">        self.setItem(i, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksortofloop</span><span class="params">(self, left, right)</span>:</span> <span class="comment"># left 和 right 为首尾元素的下标</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 初始化</span></span><br><span class="line">            i = left</span><br><span class="line">            j = i+<span class="number">1</span></span><br><span class="line">            pivot = self.getItem(i)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 大循环条件，j不能超过链表长度</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt;= right):</span><br><span class="line">                <span class="comment"># 如果 j 指向的值大于等于基准数字，直接跳过</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt;= right <span class="keyword">and</span> self.getItem(j) &gt;= pivot):</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 否则，j 指向的值小于基准，则交换</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt;= right):</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    self.swapItem(i, j)</span><br><span class="line">                    self.print()</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            self.swapItem(left, i)</span><br><span class="line">            self.quicksortofloop(left, i<span class="number">-1</span>)</span><br><span class="line">            self.quicksortofloop(i+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    L = LinkList()</span><br><span class="line">    L.create([<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    L.quicksortofloop(<span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">    L.print()</span><br></pre></td></tr></table></figure>
<pre><code>4 2 5 3 7 9 0 1 
4 2 3 5 7 9 0 1 
4 2 3 0 7 9 5 1 
4 2 3 0 1 9 5 7 
1 0 3 2 4 9 5 7 
0 1 3 2 4 9 5 7 
0 1 2 3 4 9 5 7 
0 1 2 3 4 9 5 7 
0 1 2 3 4 7 5 9 
0 1 2 3 4 5 7 9 
</code></pre><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p><strong>堆排序</strong> 利用了堆这种数据结构。二叉堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者总是大于）它的父节点。</p>
<p>通常堆是通过一维数组来实现的。在数组起始位置为 0 的情形中：</p>
<ul>
<li>父节点 <code>i</code> 的左子节点在位置 <code>(2i+1)</code>;</li>
<li>父节点 <code>i</code> 的右子节点在位置 <code>(2i+2)</code>;</li>
<li>子节点 <code>i</code> 的父节点在位置 <code>floor((i-1)/2)</code>;</li>
</ul>
<p>堆排序算法的运作如下（以从小到大排序为例）：</p>
<ol>
<li>由输入的无序数组构造一个最大堆（父结点的值总是大于它的孩子节点），作为初始的无序区；</li>
<li>把堆顶元素（最大值）和堆尾元素（堆按层次遍历的最后一个元素，即实现堆的数组的最后一个元素）互换，这时候数组最后一个元素就已经是最大元素了；</li>
<li>排除堆尾元素，对剩下的堆重新维持一个最大堆的结构；</li>
<li>持续每次对越来越少的元素重复步骤2 ~ 3，直到当前堆的大小为 1，此时按照层次遍历的顺序输出堆即是排序后的数组。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 内部比较排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(nlogn)</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- O(nlogn)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(nlogn)</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(1)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 不稳定，不稳定发生在堆顶元素与堆尾元素交换的时刻</span><br></pre></td></tr></table></figure>
<p>堆排序具体有如下两个关键步骤：</p>
<p><strong>I. 初始化最大堆</strong></p>
<p>初始化建堆过程首先会将输入的无序数组看作一个二叉树（使无序数组先满足二叉树的结构性质），然后只需要由下至上、由右至左（即：对数组逆序地进行遍历）地对所有非叶子节点（即有孩子的节点）调用 <code>sift_down()</code>  函数（构建最大堆时，该函数会将当前节点与它的左右子节点中较大的那一个交换，使得该节点一直下沉，直到它比左右子节点都大为止）将他们调整到合适的位置即可。</p>
<ul>
<li><strong>为什么不需要操作叶子节点</strong>：倒数第二层的节点调整位置时已经考虑到了跟最后一层节点之间的大小关系；</li>
<li><strong>为什么要逆序地遍历节点</strong>：因为建堆是一个节点下沉的过程，当一个节点向下沉的时候，必须确保它的左子树和右子树都已经满足了最大堆/最小堆的性质，这样才能确保当前节点下沉时换上来的那个值一定是当前节点的所有孩子节点中最大/最小的那一个，从而保证整体的最大堆/最小堆性质不被打破；  </li>
</ul>
<p>假设该二叉树一共有 $k$ 层（根节点算第一层），则除了第 $k$ 层（这一层不一定满节点）外，第 $i$ 层的节点数为 $2^{(i-1)}$​。建堆过程中:</p>
<blockquote>
<p>倒数第二层（即第 $k-1$​ 层）的节点共有 $2^{(k-2)}$​ 个，每个节点在最坏情况下（即：该节点需要沉到最后一层）进行下沉时需要交换 1 次；</p>
<p>倒数第三层（即第 $k-2$​ 层）的节点共有 $2^{(k-3)}$​ 个，每个节点在最坏情况下（即：该节点需要沉到最后一层）进行下沉时最多需要交换 2 次；</p>
<center>...</center>

<p>根节点（即第 1 层）在最坏情况下（即：该节点需要沉到最后一层）进行下沉时最多需要交换 $(k-1)$​ 次；</p>
</blockquote>
<p>总结可以得到：第 $i$​ 层的节点共有 $2^{(i-1)}$​ 个，每个节点在最坏情况下（即：该节点需要沉到最后一层）进行下沉时最多需要交换 $k-i$​ 次，则该层总共需要的交换次数为 $2^{(i-1)} \times (k-i)$​ 次。其中 $i=(k-1),(k-2),…,1$​。</p>
<p>因此，在最坏情况下，完成建堆过程总共需要进行 $\sum_{i=k-1}^{1}[2^{(i-1)} \times (k-i)]$​ 次交换。注意到，节点数量为 $n$​ 的完全二叉树的高度 $k$​ 大致为 $\log n$​，因此代入 $k = \log n$​，建堆过程需要的时间复杂度为 $T(n) = \sum_{i=\log n-1}^{1}[2^{(i-1)} \times (\log n-i)]$​。下面是 $T(n)$​ 的求解过程：</p>
<script type="math/tex; mode=display">T(n) = \frac{2^{\log n}}{4}\times1 + \frac{2^{\log n}}{8}\times2 + \frac{2^{\log n}}{16}\times3 + ... + \frac{2^{\log n}}{2^{\log n}}\times(\log n-1)\\
= \frac{n}{4}\times1 + \frac{n}{8}\times2 + \frac{n}{16}\times3 + ... + \frac{n}{2^{\log n}}(\log n-1)</script><script type="math/tex; mode=display">2T(n) = \frac{n}{2}\times1 + \frac{n}{4}\times2 + \frac{n}{8}\times3 + ... + \frac{n}{2^{\log n-1}}(\log n-1)</script><script type="math/tex; mode=display">2T(n) - T(n) = \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + ... + \frac{n}{2^{\log n-1}} - \frac{n}{2^{\log n}}\times (\log n-1) \\
= n\times\bigg[\frac{1}{2} + \frac{1}{4} + \frac{1}{8} + ... + \frac{1}{2^{\log n-1}}\bigg] - \bigg[\frac{n}{2^{\log n}}\times (\log n-1)\bigg] \\
= n\times\bigg[\frac{1}{2} + \frac{1}{4} + \frac{1}{8} + ... + \frac{1}{2^{\log n-1}}\bigg] - \bigg(\log n-1\bigg) \\
\leq n - (\log n - 1) \leq n</script><p>即：$T(n) \leq O(n)$​，因此建堆过程的最差时间复杂度为 $O(n)$​。</p>
<p><strong>II. 排序重建堆</strong></p>
<p>交换堆顶元素和堆尾部元素后，需要对堆进行重建以维持最大堆结构：只需要对交换后新的堆顶元素调用 <code>sift_down()</code> 函数下沉到合适的位置即可。而对于高度为 $k$​ 的堆，堆顶元素下沉时最坏情况下（即：该元素被下沉到堆的最后一层），最多需要交换 $k$​ 次。注意到，节点数量为 $n$​ 的完全二叉树的高度 $k$​ 大致为 $\log n$​，因此代入 $k=\log n$​。</p>
<p>需注意每次重建意味着有一个节点出堆（交换后，新的堆尾元素被排除出堆），所以每经过一次重建，都需要将堆的容量减 1（容量从 $n$​​ 减少到 1）。排序过程一共需要重建最大堆 $n-1$​​ 次，总的比较/交换次数为：$\log n + \log(n-1) + … + \log3 + \log2 = \log(n!)$​​。</p>
<blockquote>
<p>可以证明 $\log(n!)$ 和 $n\log(n)$ 是同阶无穷大：</p>
<script type="math/tex; mode=display">\because \big(\frac{n}{2}\big)^{\frac{n}{2}} \leq n! \leq n^n</script><p><script type="math/tex">\therefore \big(\frac{n}{4}\big)\log n = \big(\frac{n}{2}\big)\log (n^{\frac{1}{2}}) \leq \big(\frac{n}{2}\big)\log (\frac{n}{2}) \leq \log(n!) \leq log(n^n) = n \log n</script>​</p>
<p>显然 $(\frac{n}{4})\log{n}$​​ 与 $n\log{n}$​​ 同阶，根据夹逼理论，可证 $\log(n!)$​​ 和 $n\log(n)$​​ 同阶。</p>
</blockquote>
<p>因此所有重建过程的时间复杂度总合为 $O(n\log n)$。</p>
<p><strong>完整的时间复杂度</strong></p>
<p>完整的时间复杂度为上述两者中较为高阶的 $O(n\log n)$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(start, end)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        维持下标 start 对应的节点在最大堆中的位置： -&gt; 即 start 对应的节点的 percDown 过程</span></span><br><span class="line"><span class="string">        start: 目标节点的下标</span></span><br><span class="line"><span class="string">        end: 最大堆堆尾位置的下标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        root = start</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            child = <span class="number">2</span> * root + <span class="number">1</span> <span class="comment"># child 为 root 的左子树的索引</span></span><br><span class="line">            <span class="keyword">if</span> child &gt; end: <span class="comment"># 超出索引范围</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> alist[child] &lt; alist[child + <span class="number">1</span>]: <span class="comment"># 如果左子树的值比右子树小</span></span><br><span class="line">                child += <span class="number">1</span> <span class="comment"># 则需要将 root 和它的右子树比较大小，因此将 child 设置为 root 的右子树的索引</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># root 和它的两个子树中较大的那个（即 child）比较大小：如果 root 较小，则下沉</span></span><br><span class="line">            <span class="keyword">if</span> alist[root] &lt; alist[child]:</span><br><span class="line">                alist[root], alist[child] = alist[child], alist[root]</span><br><span class="line">                root = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment"># 创建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range((len(alist) - <span class="number">2</span>) // <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 反向遍历：从最后一个非叶子节点（即数组最后一个节点的父节点）遍历到根节点</span></span><br><span class="line">        sift_down(start, len(alist) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 堆排序主体过程</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(len(alist) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        alist[<span class="number">0</span>], alist[end] = alist[end], alist[<span class="number">0</span>] <span class="comment"># 交换堆顶元素和堆尾部元素</span></span><br><span class="line">        sift_down(<span class="number">0</span>, end - <span class="number">1</span>) <span class="comment"># 重新维护最大堆结构</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alist = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">heapSort(alist)</span><br></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><p><strong>桶排序</strong> 将数组中的元素按照一定的规则（如：使用某种映射函数将元素映射到桶中等；一般情况下会按照数值区间来进行分配）分配到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p>
<ul>
<li>由于桶排序本身不是基于比较算法的排序（不考虑每个桶内使用的排序算法），因此不受<strong>基于比较的排序算法时间复杂度下限</strong> <code>O(nlogn)</code> 的影响，甚至可以达到 <code>O(n)</code> 的时间复杂度。</li>
<li>如果数组的数据是均匀分布在某一个区间上，则桶排序的效果较好。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 不基于比较的排序（不考虑每个桶内部使用的排序算法）</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- 若只使用了一个桶，即桶的个数 m &#x3D; 1，则相当于没有使用桶排序，整体时间复杂度等同于桶内部排序算法的时间复杂度</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 若将桶的个数 m 设定为等于原数组的元素个数 n，且原数组内的数值是均匀分配时，则时间复杂度为 O(n)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n + nlogn - nlogm)，其中 m 为桶的个数，n 为原数组元素的个数</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(n + m)，其中 m 为桶的个数，n 为原数组元素的个数</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定（不考虑每个桶内部使用的排序算法）</span><br></pre></td></tr></table></figure>
<p><strong>关于时间复杂度</strong>：</p>
<ul>
<li>若原数组有 n 个元素，算法使用了 m 个桶，则平均时间复杂度的计算如下：<ol>
<li>将每个元素分配/映射到对应的桶中：这一步一共进行了 n 次，因此时间复杂度为 $O(n)$；</li>
<li>每个桶内部进行排序：若映射函数能将元素比较平均地分配到每一个桶中，则每个桶中都有 $\frac{n}{m}$ 个元素；假设桶内部使用最快的比较排序算法（达到基于比较排序算法的时间复杂度下限），则每个桶内部排序的时间复杂度为 $O(\frac{n}{m} \times log(\frac{n}{m}))$；一共有 m 个桶，因此这一步的时间复杂度为 $O(m \times \frac{n}{m} \times log(\frac{n}{m}))$；</li>
</ol>
</li>
<li>则总的时间复杂度为：$O(n) + O(m \times \frac{n}{m} \times log(\frac{n}{m})) = O(n + nlogn - nlogm)$，这表明当 n 不变时，桶的个数 m 越大（越接近 n ），总的时间复杂度就趋向于越小。</li>
<li>如果桶的个数 m 等于原数组元素个数 n，则上述时间复杂度就达到了线性的 $O(n)$。</li>
</ul>
<p><strong>关于空间复杂度</strong>：<br>桶排序中，需要创建 m 个额外空间用于记录每个桶，以及 n 个额外空间用于将所有元素放入桶中，因此总的空间复杂度为 $O(n + m)$​。</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p><strong>整型桶排序（m=n）</strong></p>
<p>当每个元素都是整型时，如果将桶的个数 m 设定为等于原数组的元素个数 n，即每个桶能够对应一个特定元素，则可以省去桶内部排序的过程，达到时间复杂度 <code>O(n)</code>；同时由于 <code>m == n</code>，可以得到空间复杂度也为 <code>O(n)</code>。对于整数数组 <code>A</code> 的桶排序具体步骤如下：</p>
<ol>
<li>计算得到数组 <code>A</code> 的最大值 <code>max</code> 和最小值 <code>min</code>；</li>
<li>申请一个数组 <code>S</code>，里面含有 <code>(max-min+1)</code> 个桶，每个桶的值初始化为 0（数组 <code>S</code> 的每一个位置代表一个桶）；</li>
<li>然后遍历数组 <code>A</code>，遍历到 <code>A[i]</code> 时，将 <code>S[A[i]-min]</code> 的值增加 1。当遍历结束后，S 记录了每个数字出现的次数；</li>
<li>所有输入被读进后，扫描数组 <code>S</code>，对于 <code>S</code> 的下标为 <code>i</code> 的位置，输出 <code>s[i]</code> 个 <code>(i+min)</code>，就能得出排好序的结果。</li>
</ol>
<p>【例子】：<br>举个例子，若要排序一个数组 <code>[5,3,6,1,2,7,5,10]</code>，由于值都在 1-10 之间，因此建立 10 个桶：  </p>
<p><code>[0 0 0 0 0 0 0 0 0 0]</code>    （桶）  </p>
<p><code>[1 2 3 4 5 6 7 8 9 10]</code>   （桶对应的数值）  </p>
<p>遍历数组，第一个数字为 5，因此第五个桶的值加 1：<code>[0 0 0 0 1 0 0 0 0 0]</code></p>
<p>第二个数字为 3，因此第三个桶的值加 1：<code>[0 0 1 0 1 0 0 0 0 0]</code></p>
<p>…</p>
<p>遍历后</p>
<p><code>[1 1 1 0 2 1 1 0 0 1]</code> （桶的值）</p>
<p>输出</p>
<p><code>[1 2 3 5 5 6 7 10]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    A: input list</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    n = len(A)</span><br><span class="line">    Amax = max(A)</span><br><span class="line">    Amin = min(A)</span><br><span class="line">    s = [<span class="number">0</span>] * (Amax - Amin + <span class="number">1</span>) <span class="comment"># buckets</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s[A[i] - Amin] += <span class="number">1</span> <span class="comment"># 记录各个数字出现次数</span></span><br><span class="line">    </span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">while</span> s[i] &gt; <span class="number">0</span>:</span><br><span class="line">            output.append(i + Amin)</span><br><span class="line">            s[i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">-3</span>,<span class="number">15</span>]</span><br><span class="line">print(bucketSort(A))</span><br></pre></td></tr></table></figure>
<pre><code>[-3, 1, 2, 3, 5, 5, 6, 7, 10, 15]
</code></pre><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p><strong>区间 [0,1) 上均匀分布的桶排序 (m=n)</strong></p>
<p>当输入符合均匀分布时，例如，元素均匀的分布在区间 <code>[0,1)</code> 上，可以将桶排序与其它排序方法结合使用。</p>
<p>如果序列的长度为 n，就将 <code>[0,1)</code> 划分成 n 个相同大小的子区间（桶 <code>s</code>），然后将 n 个输入数放入它们所属数值区间对应的各个桶中（例如：假如输入 10 个数，则把区间 <code>[0,1)</code> 均匀划分为 10 个区间，而 0.09 落在区间 <code>[0, 0.1)</code>，所以 0.09 分配到桶 <code>s[0]</code>）。对各个桶中的数进行内部排序，然后按照次序把各桶中的元素列出来即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    A: input list, A中元素在0~1之间</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    n = len(A)</span><br><span class="line">    s = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 生成 n 个桶：每个桶是一个空白列表，每个桶代表将区间 [0,1) n 等分后的一个子区间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">        s[int(x * n)].append(x) <span class="comment"># 将 x 分配到对应的子区间中：每个子区间长度为 1/n，x 就在下标为 int(x/(1/n)) 的桶内</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        s[i].sort() <span class="comment"># 对每个桶进行排序</span></span><br><span class="line">    </span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># 将每个桶中的元素列出来</span></span><br><span class="line">        output.extend(s[i])</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">0.09</span>,<span class="number">0.27</span>,<span class="number">0.81</span>,<span class="number">0.03</span>,<span class="number">0.48</span>]</span><br><span class="line">print(bucketSort(A))</span><br></pre></td></tr></table></figure>
<pre><code>[0.03, 0.09, 0.27, 0.48, 0.81]
</code></pre><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><p><strong>一般情况下的桶排序（m&lt;=n）</strong></p>
<p>在一般情况下，对于数组 <code>A</code> 的桶排序具体步骤如下：</p>
<ol>
<li>计算得到数组 <code>A</code> 的最大值 <code>max</code> 和最小值 <code>min</code>以及数组长度 <code>n</code>；</li>
<li>设定一个小于 <code>n</code> 的整数 <code>m</code> 作为桶的个数；</li>
<li>申请一个数组 <code>S</code>，里面含有 <code>m</code> 个桶，每个桶的值初始化为 0（数组 <code>S</code> 的每一个位置代表一个桶）；</li>
<li>将区间 <code>[min, max]</code> 分为 <code>m</code> 等分，得到 <code>m</code> 个 <code>[·,·)</code> 型子区间（<strong>注意</strong>：最后一个子区间需要是 <code>[·,·]</code>型，用于将 <code>max</code> 包括进去），每个子区间对应一个桶；</li>
<li>把数组 <code>A</code> 的每个元素按照所在子区间分配到对应的一个桶中，具体步骤如下：<ul>
<li>由于 <code>[min, max]</code> 被分为了 <code>m</code> 等分，因此每个子区间的长度为：$width = \frac{max - min}{m}$；</li>
<li>显然元素 <code>x</code> 落在第 <code>i</code> 个区间，其中 $i = int(\frac{x - min}{width}) = int(\frac{(x - min)m}{max - min})$；</li>
<li>因此，将元素 <code>x</code> 分配到第 <code>i</code> 个桶，即 <code>S[i]</code> 对应的桶；</li>
<li><strong>注意</strong>：数组中最大的元素 <code>max</code> 需要将直接放到最后一个桶中；</li>
</ul>
</li>
<li>每个桶进行内部排序（使用某种排序算法）；</li>
<li>按顺序将每个桶内排好序的序列输出，就得到了整体排序完成的序列。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span><span class="params">(A, m)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    A: input list</span></span><br><span class="line"><span class="string">    m: number of buckets</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    n = len(A)</span><br><span class="line">    Amin = min(A)</span><br><span class="line">    Amax = max(A)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    s = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="comment"># 生成 m 个桶：每个桶是一个空白列表，每个桶代表将区间 [min,max] m 等分后的一个子区间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> x == Amax: <span class="comment"># 处理特例：max</span></span><br><span class="line">            s[<span class="number">-1</span>].append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s[int((x - Amin) * m / (Amax - Amin))].append(x) <span class="comment"># 将 x 分配到对应的子区间中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        s[i].sort() <span class="comment"># 对每个桶进行排序</span></span><br><span class="line">    </span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)): <span class="comment"># 将每个桶中的元素列出来</span></span><br><span class="line">        output.extend(s[i])</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">0.09</span>,<span class="number">81</span>,<span class="number">1000</span>,<span class="number">-23</span>,<span class="number">0</span>,<span class="number">0.78</span>,<span class="number">9.2</span>]</span><br><span class="line">print(bucketSort(A,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[-23, 0, 0.09, 0.78, 9.2, 81, 1000]
</code></pre><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><p><strong>计数排序</strong> 基本思想是对于给定的输入序列中的每一个元素 x ，确定该序列中值小于等于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于等于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。</p>
<p><strong>类型一：适用于非负整数</strong><br>对每一个输入的元素 <code>A[i]</code>，通过辅助数组 <code>c</code>（而不是通过比较大小）确定 <code>A</code> 中小于等于 <code>A[i]</code> 的元素个数，具体方法为：  </p>
<ol>
<li>计算得到 <code>k = max(A)</code>，以此确定输入数组的范围为 <code>0 ~ k</code>（因为是非负整数），然后申请一个长为 <code>(k+1)</code> 的数组 <code>c</code>（其下标为 <code>0 ~ k</code>，原始数组中的每个数都能对应一个下标）；  </li>
<li>遍历原数组 <code>A</code>，用 <code>c[x]</code> 储存 <code>A</code> 中数字 <code>x</code> 出现的次数；  </li>
<li>遍历辅助数组 <code>c</code>，将 <code>c[x]</code> 更新为 <code>A</code> 中小于等于 <code>x</code> 的数字出现的总次数；  </li>
<li>申请输出数组 <code>output</code>，然后<strong>逆序</strong>遍历原始数组 <code>A</code>，对于 <code>A</code> 的每一个元素，基于辅助数组 <code>c</code> 的信息将该元素放入它排序后应该在的位置（例如：遍历到 <code>A</code> 中的一个元素 x，如果<code>c[x] == 17</code>，则表明原数组中共有 17 个元素小于等于 <code>x</code>，因此将该元素 <code>x</code> 放在 <code>output[16]</code> 的位置）；</li>
<li><strong>注意</strong>：每将一个元素 <code>x</code> 放入 <code>output</code> 对应的位置后，需要同步地将相应的 <code>c[x]</code> 的值减去 1。这是因为，如果在继续遍历 <code>A</code> 的过程中，又遇到了重复的元素 <code>x</code>，则这个新的 <code>x</code> 在放入 <code>output</code> 中时，需要放在上一个放入的 <code>x</code> 的前面（不能抢占上一个 <code>x</code> 的位置；而由于“小于等于”的条件，它也不能放到上一个 <code>x</code> 的后面）。</li>
<li><strong>注意</strong>：在步骤 4 中，之所以要<strong>逆序</strong>遍历原始数组 <code>A</code>，是因为在遍历遇到重复元素 <code>x</code> 时，之后遇到的那个 <code>x</code> 会被放在上一个遇到的 <code>x</code> 的前面，因此，如果不逆序遍历 <code>A</code> 的话，就无法保证算法的稳定性。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 不基于比较的排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(n + k)，其中 k 为原始数组中的最大元素的值</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 如果原始数组中的最大元素的值 k 远小于原始数组的元素个数 n，则时间复杂度为 O(n)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n + k)，其中 k 为原始数组中的最大元素的值</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(k)，其中 k 为原始数组中的最大元素的值，辅助空间就是辅助数组 c 所需的空间 O(k)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<p><strong>关于时间复杂度</strong>：步骤 2 中遍历 <code>A</code> 需要时间为 <code>O(n)</code>；步骤 3 中遍历 <code>c</code> 需要时间为 <code>O(k)</code>；步骤 4 中逆序遍历 <code>A</code> 需要时间为 <code>O(n)</code>；三者相加得到整体的时间复杂度为 <code>O(n + k)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    k = max(A)</span><br><span class="line">    n = len(A)  <span class="comment"># 计算序列的长度</span></span><br><span class="line">    output = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]  <span class="comment"># 设置输出序列并初始化为 0</span></span><br><span class="line">    c = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(k + <span class="number">1</span>)]  <span class="comment"># 设置计数序列并初始化为 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 首先用 c[x] 储存 A 中数字 x 出现的次数 -- O(n)</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">        c[x] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 然后更新 c[x] 为 A 中小于等于 x 的数字出现的总次数 -- O(k)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">        c[i] = c[i] + c[i<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 基于数组 c 将 A 中数字x放入它排序后应该在的位置，然后相应的 c[x] 减去 1 -- O(n)</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A[::<span class="number">-1</span>]: <span class="comment"># 逆序遍历</span></span><br><span class="line">        output[c[x] - <span class="number">1</span>] = x</span><br><span class="line">        c[x] -= - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">17</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">15</span>]</span><br><span class="line">print(countingSort(A))</span><br></pre></td></tr></table></figure>
<pre><code>[3, 4, 5, 7, 9, 15, 17]
</code></pre><p><strong>优化：突破非负整数的限制</strong><br>之所以会有非负整数的限制，是因为列表 <code>c</code> 的下标自然地从 0 开始标，导致他能标记的元素值被限定在 0~k 的范围内。因此如果考虑使用一个字典 <code>d[x]</code> 代替列表 <code>c[x]</code> 来储存 <code>A</code> 中小于等于元素 <code>x = A[i]</code> 的元素个数，用键值取代下标，就能实现从 <code>min(A) ~ max(A)</code> 的标号，从而突破这一限制，将负数也纳入考虑范围。（也可以考虑通过滑动调整下标突破这一限制：让 <code>c[x - min(A)]</code> 储存 <code>A</code> 中小于等于元素 <code>x = A[i]</code> 的元素个数即可）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 不基于比较的排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(n + max(A) - min(A))</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 如果 (max(A) - min(A)) 远小于原始数组的元素个数 n，则时间复杂度为 O(n)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(n + max(A) - min(A))</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(max(A) - min(A))，辅助空间就是辅助数组 c &#x2F;辅助字典 d 所需的空间 O(max(A) - min(A))</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<p><strong>关于时间复杂度</strong>：步骤 2 中遍历 <code>A</code> 需要时间为 <code>O(n)</code>；步骤 3 中遍历 <code>c</code> 需要时间为 <code>O(max(A) - min(A))</code>；步骤 4 中逆序遍历 <code>A</code> 需要时间为 <code>O(n)</code>；三者相加得到整体的时间复杂度为 <code>O(n + max(A) - min(A))</code>。</p>
<p>下面的代码使用字典来进行优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    keys = range(min(A), max(A)+<span class="number">1</span>) <span class="comment"># A 中最小元素到最大元素作为键值，取代下标</span></span><br><span class="line">    values = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max(A) - min(A) + <span class="number">1</span>)] <span class="comment"># 设置计数序列并初始化为 0</span></span><br><span class="line">    d = dict(zip(keys, values)) <span class="comment"># 设置计数字典</span></span><br><span class="line">    </span><br><span class="line">    n = len(A)  <span class="comment"># 计算序列的长度</span></span><br><span class="line">    </span><br><span class="line">    output = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]  <span class="comment"># 设置输出序列并初始化为 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 首先用d[x]储存A中数字x出现的次数 -- O(n)</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">        d[x] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 然后更新 d[x] 为 A 中小于等于 x 的数字出现的总次数 -- O(max(A) - min(A))</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(min(A)+<span class="number">1</span>, max(A)+<span class="number">1</span>):</span><br><span class="line">        d[x] = d[x] + d[x<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 基于字典 d 将 A 中数字 x 放入它排序后应该在的位置，然后相应的 d[x] 减去 1 -- O(n)</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> A[::<span class="number">-1</span>]: <span class="comment"># 逆序遍历</span></span><br><span class="line">        output[d[x] - <span class="number">1</span>] = x</span><br><span class="line">        d[x] -= - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">17</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">-9</span>,<span class="number">-12</span>]</span><br><span class="line">print(countingSort(A))</span><br></pre></td></tr></table></figure>
<pre><code>[-12, -9, 3, 4, 5, 7, 9, 15, 17]
</code></pre><p><strong>类型二：基于比较的计数排序</strong></p>
<p>这个类型的计数排序无法突破基于比较的排序算法的时间复杂度下界 <code>O(nlogn)</code>，但是可以用于包含负数的数据。具体思路如下：</p>
<p>对输入数组中的每一个数 <code>A[i]</code>，通过<strong>比较</strong>确定出小于 <code>A[i]</code> 的数字的总个数 <code>p</code> 和等于 <code>A[i]</code> 的数字的总个数 <code>q</code>。有了这一信息就可以把 <code>A[i]</code> 直接放到排序后数组中的相应位置（排序后数组的下标为 <code>p</code> 到 <code>(p + q)</code> 的位置上都应该放置 <code>A[i]</code>）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    A: input list</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    n = len(A)</span><br><span class="line">    output = [<span class="literal">None</span>] * n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        p = <span class="number">0</span> <span class="comment"># p 用于储存所有数字中小于 A[i] 的数字的个数</span></span><br><span class="line">        q = <span class="number">0</span> <span class="comment"># q 用于储存所有数字中等于 A[i] 的数字的个数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> A[j] &lt; A[i]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[j] == A[i]:</span><br><span class="line">                q += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(p, p+q): <span class="comment"># 将数字放在输出数组的对应位置上</span></span><br><span class="line">            output[k] = A[i]</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-9</span>]</span><br><span class="line">print(countingSort(A))</span><br></pre></td></tr></table></figure>
<pre><code>[-9, 2, 2, 3, 3, 5, 6, 8, 9]
</code></pre><h2 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h2><p><strong>基数排序</strong> 当数组中的元素都是<strong>非负整数</strong>时候，可以考虑使用基数排序。基数排序的基本思想就是：把元素从个位排好序，然后再从十位排好序，重复直到元素中最大数的最高位排好序，那么整个元素就排好序了。</p>
<p>假设使用十进制数字（即基数 B=10），且输入列表 A 中最大数字的最高位数是 m 位，则基数排序的算法过程如下：</p>
<ol>
<li>根据设定的基数 B 划分出 B 个桶：例如，按照十进制（基数 B=10），则分为 0 ~ 9 这十个桶；</li>
<li>遍历位数，从个位、十位、… 到第 m 位进行 m 次分桶（从低位向高位进行），具体分桶操作如下：<ul>
<li>分配：遍历原数组，将数字按照当前位数分配到对应的桶中。例如，数字为 327，当前是按照十位数分桶，则 327 会被分到 2 号桶；若是数字 10，当前按照个位数分桶，则 10 会被分到 0 号桶；</li>
<li>收集：每次分桶完毕后，按桶的顺序排列依次输出桶内数字，得到一个新的序列；</li>
<li>下一轮（即基于下一个位数）的分桶将针对上述新序列进行；</li>
</ul>
</li>
<li>所有分桶结束后（即最高位 m 位也完成分桶），按桶的顺序排列依次输出桶内数字就能得到排序完成的序列。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 分类 -------------- 不基于比较的排序</span><br><span class="line">&#x2F;&#x2F; 数据结构 ---------- 数组</span><br><span class="line">&#x2F;&#x2F; 最差时间复杂度 ---- O(m * (n + B))</span><br><span class="line">&#x2F;&#x2F; 最优时间复杂度 ---- 当最大值最高位的位数 m 和选取的基数 B 选小于元素个数 n 时（m 和 B 在 n面前忽略不计），时间复杂度为 O(n)</span><br><span class="line">&#x2F;&#x2F; 平均时间复杂度 ---- O(m * (n + B))</span><br><span class="line">&#x2F;&#x2F; 所需辅助空间 ------ O(n + B)</span><br><span class="line">&#x2F;&#x2F; 稳定性 ------------ 稳定</span><br></pre></td></tr></table></figure>
<p><strong>关于时间复杂度</strong>：</p>
<p>基数排序一共进行了 m 次分桶操作，而每次分桶操作中包含以下两个部分：</p>
<ol>
<li>分配步骤：把原数组的每个元素都分配到一个对应的桶中。由于 n 个元素每个都被分配了一次，因此这一步的时间复杂度为 <code>O(n)</code>；</li>
<li>收集步骤：把每个桶中的所有元素依次输出到一个新的序列中。由于 B 个桶每个都被收集了一次（每个桶内所有元素以一个数组为单位被输出，因此只有一次操作），因此这一步的时间复杂度为 <code>O(B)</code>；</li>
</ol>
<p>因此，m 次分桶操作的总体时间复杂度为 <code>O(m * (n + B))</code>，这也就是基数排序的平均时间复杂度。</p>
<p><strong>关于空间复杂度</strong>：</p>
<p>需要创建 B 个额外空间用于记录每个桶，以及 n 个额外空间用于将所有元素放入桶中，因此总的空间复杂度为 <code>O(n + B)</code>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>基数排序适用于<strong>非负整数</strong>；</li>
<li>数组元素的最大值和最小值差距如果比较小，则比较适用基数排序；</li>
<li>基数排序可以看做是特殊的桶排序：普通的桶排序是按值区间划分桶，而基数排序是按数位来划分；基数排序可以看做是多轮桶排序，每个数位上都进行一轮桶排序；</li>
<li>如果使用数组元素的最大值作为基数，基数排序就退化成了计数排序；</li>
<li>对于某个数组，如果使用二进制（取 B = 2）进行基数排序，则相比其他基数选值，B 达到了可能的最小值 2，相应地，这个进制下，数组元素的最高位数 m 就达到了最大值，时间复杂度 O(m * (n + B)) 会变大，空间复杂度 O(n + B) 会变小；</li>
<li>对于某个数组，如果使用其元素的最大值作为基数进行基数排序， 则相比其他基数选值，B 达到了可能的最大值，相应地，这个进制下，最高位数 m 仅为 1，时间复杂度 O(m * (n + B)) 会变小，空间复杂度 O(n + B) 会急剧增大，此时基数排序退化成了计数排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radixSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    A: input list</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    n = len(A)</span><br><span class="line">    B = <span class="number">10</span> <span class="comment"># 十进制下的基数设为10</span></span><br><span class="line">    m = len(str(max(A))) <span class="comment"># A中数字的最高位数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(m): <span class="comment"># 进行m次分桶</span></span><br><span class="line">        s = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(B)] <span class="comment"># 按照基数设定桶</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            s[x//(<span class="number">10</span>**k) % <span class="number">10</span>].append(x) <span class="comment"># 按照对应位数分桶, 显然 x//(10**k) % 10 就是 x 从右往左第 k+1 位对应的数字</span></span><br><span class="line">        A = [j <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">for</span> j <span class="keyword">in</span> i] <span class="comment"># 按照桶的顺序更新数组：i 表示 s 中的每一个桶， j 表示桶 i 中的每一个数</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<p>代码测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="number">99</span>, <span class="number">108</span>, <span class="number">425</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">809</span>, <span class="number">32</span>, <span class="number">78</span>, <span class="number">933</span>, <span class="number">26</span>, <span class="number">3397</span>]</span><br><span class="line">print(radixSort(A))</span><br></pre></td></tr></table></figure>
<pre><code>[0, 10, 26, 32, 78, 99, 108, 425, 809, 933, 3397]
</code></pre>
    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://lingfengzhu.github.io">Lingfeng Zhu</a>
            <p>Original Link：<a href="https://lingfengzhu.github.io/2020/11/15/SortAlgorithm/">https://lingfengzhu.github.io/2020/11/15/SortAlgorithm/</a> 
            <p>Published：<a href="https://lingfengzhu.github.io/2020/11/15/SortAlgorithm/">November 15th 2020, 8:35:38 am</a>
            <p>Updated：<a href="https://lingfengzhu.github.io/2020/11/15/SortAlgorithm/">September 8th 2021, 6:35:10 pm</a>
            <p>Copyright：This Article Uses <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">Attribution-NonCommercial 4.0 International</a> as the license</p> 
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/11/16/Time-Complexity/" title= "Time Complexity">
                    <div class="nextTitle">Time Complexity</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/06/29/BinarySearch/" title= "Binary Search">
                    <div class="prevTitle">Binary Search</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:jolin.windy072@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/LingfengZhu" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechatQR.jpeg" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="//www.facebook.com/lingfeng.zhu.18/" class="iconfont-archer facebook" target="_blank" title=facebook></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="//www.linkedin.com/in/lingfeng-zhu-256315193/" class="iconfont-archer linkedin" target="_blank" title=linkedin></a>
            
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="about">Powered by <a href="https://lingfengzhu.github.io/about/" target="_blank">Vinn</a></span><span class="iconfont-archer power">&#xe635;</span><span id="instituion-info">from <a href="https://www.wisc.edu/" target="_blank">UWM</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Definitions"><span class="toc-number">1.</span> <span class="toc-text">Basic Definitions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bubble-Sort"><span class="toc-number">2.</span> <span class="toc-text">Bubble Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Short-Bubble-Sort"><span class="toc-number">2.1.</span> <span class="toc-text">Short Bubble Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cocktail-Sort"><span class="toc-number">2.2.</span> <span class="toc-text">Cocktail Sort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selection-Sort"><span class="toc-number">3.</span> <span class="toc-text">Selection Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Insertion-Sort"><span class="toc-number">4.</span> <span class="toc-text">Insertion Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Insert-Sort"><span class="toc-number">4.1.</span> <span class="toc-text">Binary Insert Sort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Sort"><span class="toc-number">5.</span> <span class="toc-text">Shell Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merge-Sort"><span class="toc-number">6.</span> <span class="toc-text">Merge Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Sort"><span class="toc-number">7.</span> <span class="toc-text">Quick Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linked-List-Quick-Sort"><span class="toc-number">7.1.</span> <span class="toc-text">Linked List Quick Sort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heap-Sort"><span class="toc-number">8.</span> <span class="toc-text">Heap Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bucket-Sort"><span class="toc-number">9.</span> <span class="toc-text">Bucket Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-1"><span class="toc-number">9.1.</span> <span class="toc-text">Example 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-2"><span class="toc-number">9.2.</span> <span class="toc-text">Example 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-3"><span class="toc-number">9.3.</span> <span class="toc-text">Example 3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Counting-Sort"><span class="toc-number">10.</span> <span class="toc-text">Counting Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Radix-Sort"><span class="toc-number">11.</span> <span class="toc-text">Radix Sort</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 22
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2021/09/10/TeachersDay/" >Happy Teacher's Day</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2021/09/09/CAPM/" >CAPM</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/06</span><a class="archive-post-title" href= "/2021/09/06/ERNIE/" >ERNIE</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/03</span><a class="archive-post-title" href= "/2021/09/03/Two-Pointer/" >Two-Pointer</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/30</span><a class="archive-post-title" href= "/2021/08/30/Federated-Learning/" >Federated Learning</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span><a class="archive-post-title" href= "/2021/08/27/Transfer-Learning/" >Transfer Learning</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/Decorator/" >Python Decorator</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/Python-args-and-kwargs/" >Python Syntax: *args and **kwargs</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span><a class="archive-post-title" href= "/2021/07/05/Python-Logging/" >Python Logging</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/25</span><a class="archive-post-title" href= "/2021/05/25/BERT/" >BERT</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span><a class="archive-post-title" href= "/2021/05/08/Conda/" >Conda</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/05</span><a class="archive-post-title" href= "/2021/02/05/Docker/" >Docker</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/06</span><a class="archive-post-title" href= "/2021/01/06/Trie-Tree/" >Trie Tree</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/08</span><a class="archive-post-title" href= "/2020/12/08/Gradient-Descent/" >Gradient Descent</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/16</span><a class="archive-post-title" href= "/2020/11/16/Time-Complexity/" >Time Complexity</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/15</span><a class="archive-post-title" href= "/2020/11/15/SortAlgorithm/" >Sort Algorithm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/29</span><a class="archive-post-title" href= "/2020/06/29/BinarySearch/" >Binary Search</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/2020/04/26/Delta-Method-in-Deep-Learning/" >Delta Method in Deep Learning</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/18</span><a class="archive-post-title" href= "/2020/04/18/BackTrack/" >Backtracking</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2020/04/16/Python-Syntax-with/" >Python Syntax: with</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href= "/2020/03/27/COVID-Survival-Anaysis/" >COVID-19 Survival Analysis</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href= "/2020/03/27/Hexo-Guideline/" >Hexo Guideline</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="NLP"><span class="iconfont-archer">&#xe606;</span>NLP</span>
    
        <span class="sidebar-tag-name" data-tags="Survival Analysis"><span class="iconfont-archer">&#xe606;</span>Survival Analysis</span>
    
        <span class="sidebar-tag-name" data-tags="COVID-19"><span class="iconfont-archer">&#xe606;</span>COVID-19</span>
    
        <span class="sidebar-tag-name" data-tags="Conda"><span class="iconfont-archer">&#xe606;</span>Conda</span>
    
        <span class="sidebar-tag-name" data-tags="Python"><span class="iconfont-archer">&#xe606;</span>Python</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="Hexo"><span class="iconfont-archer">&#xe606;</span>Hexo</span>
    
        <span class="sidebar-tag-name" data-tags="Web-Frontend"><span class="iconfont-archer">&#xe606;</span>Web-Frontend</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Deep-Learning"><span class="iconfont-archer">&#xe60a;</span>Deep-Learning</span>
    
        <span class="sidebar-category-name" data-categories="Algorithm"><span class="iconfont-archer">&#xe60a;</span>Algorithm</span>
    
        <span class="sidebar-category-name" data-categories="Finance"><span class="iconfont-archer">&#xe60a;</span>Finance</span>
    
        <span class="sidebar-category-name" data-categories="Statistics"><span class="iconfont-archer">&#xe60a;</span>Statistics</span>
    
        <span class="sidebar-category-name" data-categories="Syntax"><span class="iconfont-archer">&#xe60a;</span>Syntax</span>
    
        <span class="sidebar-category-name" data-categories="greeting"><span class="iconfont-archer">&#xe60a;</span>greeting</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Lingfeng Zhu"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->    
     
    </body>
</html>


